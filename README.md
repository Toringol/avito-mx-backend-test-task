# avito-mx-backend-test-task

## Решение тестового задания avito Merchant Experience

[Ссылка на задание](https://github.com/avito-tech/mx-backend-trainee-assignment)

## Логика работы и архитектура

Проект выполнен с помощью чистой архитектуры, все независимые элементы отделены
друг от друга, что облегчает тестирование и дальнейшую разработку.
Логирование выполнено с помощью многоуровневого logrus логера, для запросов работает мидлвара.

### Расположения элементов

Модели: app/models
Логика сервира: app/businessConnService/
Файлы сборки контейнеров: build/
Main файл: cmd/
Конфигурация: config/
Вспомогательные функции: tools/
Документация: docs/

### Хэндлеры

- /loadProduct (post запрос на загрузку пачки экселек на добавление продуктов в базу)
- /getProduct (get запрос на получение эксельки продуктов по пользовательским данным)
- /getTaskState/{task_id:[0-9]+} (get запрос на просмотр состояния задачи(объяснение для чего ниже))
- /getTaskStats/{task_id:[0-9]+} (get запрос на просмотр статистики задачи(объяснение также ниже))

### Асинхронная работа

При загрузке пачки xlsx файлов на хендлер /loadProduct возращается айди задачи, по которой можно
потом следить за выполнением и при завершении загрузки посмотреть всю статистику. Для каждого файла
выполняется отдельная горутина, также для каждого листа в файле выполняется отдельная горутина, статистика
собирается асинхронно с каждого листа в файле. За обработку этой асинхронности отвечает taskManager, 
расположенный в папке app/businessConnService/delivery/taskManager. Он следит за 3 событиями с помощью каналов
(пояление новой задачи, завершение задачи и остановка работы).

## Как запустить

- sudo docker-compose up --build (Сеть настроена на 172.20.0.0/16 и дефолтный 
ip контейнера будет 172.20.0.1, если по какой-то причине это не так, в config/config.yml
изменить DBHost на нужный).

При запуске данной команды запускаются два контейнера расположенные в build/, один для postgresql(
с стартовым скриптом init.sql для создания необходимых таблиц), второй для нашего сервиса.

## Документация

Swagger документация расположения в docs/swagger.yaml, там расположена документация на хэндлеры.
Остальная докумантация методов и неочевидных мест представлена в коде в виде комментариев.

## Teсты

- тесты на базу данных находятся в app/businessConnService/repository/memory_test.go (покрытие 67%)
- тесты на хэндлеры находятся в app/businessConnService/delivery/http/handlers_test.go (покрытие 73.4%)
- тесты на вспомогательные функции находятся в tools/convertXlsxRowToProductInfo_test.go (покрытие 96.9%)

## Нагрузчное тестирование

Нагрузочное тестирование было произведено с помощью postman, как и ручное тестирование при разработке, почему был
выбран postman ниже, для нагрузки были подготовлены файлы с 3 листами по 1000 продуктов, в каждом запросы было 8
таких файлов, всего выполнялось 4 параллельных запроса, серсив справляется за ~10 секунд с такой нагрузкой.

## О чем думал и почему не сделал

- Нагрузочное тестирование (хотелось сделать нормальное тестирование с помощью apache bench, но не понял как оправлять
сразу несколько multipart файлов с несколькими полями, тк в запросе еще должен быть seller_id, поэтому решил взять postman)
- Тестирование (хотелось протестировать все на 80+ процентов, но в логике работы базах данных не понял как тестирование rowsAffected, 
тк на запрос возвращается структура result, из которой мы потом берем rowsAffected, в handlers не знаю как протестировать 
невалидный json.Marshall, точнее там уже выполняется маршалл для конкретной структуры, в которую уже не вставишь доп данные,
но что самое главное не особо понимаю как тестировать горутины из-за недостатка опыта, из идей было тестировать вызовы горутин и 
просто считать сколько их запустилось, и так смотреть ожидаемое поведение)
- Архитектура (думал о выделении в отдельный сервис task manager и общении с помощью grpc или чего-нибудь другого, но подумал, что
это, наверное, оверкилл для этой задачи)

## Впечатления

Задача отличная! Некоторые вещи лучше понял, а некоторые узучил, например, работу с excel.